#!/usr/bin/perl
# Filename:	album
# Author:	David Ljung Madison <DaveSource.com>
# See License:	http://MarginalHacks.com/License
# Version:	1.10
# Description:	Makes a photo album
# Assumes:	'Back' for the top of the album is '..'
use strict;

umask 022;	# 0755

##################################################
# Setup the variables
##################################################
my $PROGNAME = $0;
$PROGNAME =~ s|.*/||;

my $CONVERT	= "convert";
my $IDENTIFY	= "identify";	# Undef if you don't have identify

# Default directory page
my $HTML	= "index.html";

my %DEFAULTS	= (
	# Thumbnail stuff
	'x'		=> 100,		# Size of thumbnails
	'y'		=> 100,
	'crop'		=> 1,		# Crop or just scale?
	'force'		=> 0,		# Force thumbnail generation
	'type'		=> "gif",	# Thumbnail image type
	'dir'		=> "tn",	# Thumbnail directory
	# Album stuff
	'columns'	=> 4,		# Number of images per row
	'sizes'		=> 0,		# Show image sizes
	'clean'		=> 0,		# Clean garbage out of thumbnail dir?
	'captions'	=> "",		# Captions filename?
	'identify'	=> 1,		# Use identify or convert for get_size?
	);

#########################
# URLs for these scripts
#########################
my $HOME	= "http://MarginalHacks.com/";
my $ALBUM_URL	= "http://MarginalHacks.com/Hacks/album";
my $GEN_STRING	= "album http://MarginalHacks.com/";
my $OLD_GEN_RE	= "Generated by <a href=.+>$PROGNAME</a> and <a href=.+>thumb</a>";

##################################################
# Usage
##################################################
sub usage {
  my $msg;
  foreach $msg (@_) { print "ERROR:  $msg\n"; }
  print "\n";
  print "Usage:\t$PROGNAME [-d] [options] <dir>\n";
  print "\tMakes a photo album\n";
  print "\n";
  print "\tAll boolean options can be turned off with '-no_option'\n";
  print "\n";
  print "Album Options:\n";
  print "\t-d               Set debug mode\n";
  print "\t-sizes           Show image sizes\n";
  print "\t-columns         Number of image columns\n";
  print "\t-sizes           Show image sizes\n";
  print "\t-clean           Clean unused thumbnails out of thumbnail dirs\n";
  print "\t-captions        Specify captions filename\n";
  print "\t-identify        Use or don't use identify program\n";
  print "\n";
  print "Thumbnail Options:\n";
  print "\t-geometry=geom   Size of thumbnail  [default ${DEFAULTS{'x'}}x${DEFAULTS{'y'}}]\n";
  print "\t-type            Thumbnail type (gif, jpg, tiff,...)\n";
  print "\t-crop            Crop the image to fit thumbnail size.\n";
  print "\t                 else aspect will be maintained\n";
  print "\t-dir             Thumbnail directory\n";
  print "\t-force           Force overwrite of existing thumbnails\n";
  print "\t                 else they are only written when changed\n";
  print "\n";
  print "Author:  David Ljung Madison, $HOME\n";
  print "\n";
  exit -1;
}

sub set_size {
  my ($opt_H,$size) = @_;
  return ($opt_H->{'x'},$opt_H->{'y'}) = ($1,$2) if ($size =~ /^(\d+)x(\d+)$/);
  usage("Can't understand geometry [$size]");
}

sub parse_args {
  my $dir;
  my %opt;

  # Defaults
  %opt = %DEFAULTS;

  while ($#ARGV>=0) {
    my $arg=shift(@ARGV);
    if ($arg =~ /^-h$/) { usage(); }
    if ($arg =~ /^-(no_?)?d$/) { $MAIN::DEBUG = $1?0:1; next; }
    if ($arg =~ /^-g(eom(etry)?)?(=(.+))?$/) { set_size(\%opt,$4 ? $4 : shift(@ARGV)); next; }
    if ($arg =~ /^-(no_?)?(.+)$/) {
      my ($no,$opt) = ($1,$2);
      usage("Unknown option: $opt") unless (defined $DEFAULTS{$opt});
      # Options that take arguments
      if ($opt eq "dir" || $opt eq "type" || $opt eq "columns" || $opt eq "captions") {
        usage("Option [$opt] can't be -no, it needs an argument") if ($no);
        $opt{$opt} = shift(@ARGV);
      } else {
        $opt{$opt} = $no ? 0 : 1;
      }
      next;
    }
    usage("Can't find directory $arg") unless (-d $arg);
    usage("Too many directories: $arg and $dir") if ($dir);
    $dir=$arg;
  }
  $dir="." unless ($dir);

  $dir =~ s|/$||;	# Little cleanup
  (\%opt,$dir);
}

##################################################
# HTML
##################################################
sub header {
  my ($dir,@names) = @_;

  my $path = join("/",@names);
  my $this = clean_name(pop(@names),undef);
  my $header;
  my $dotdot = "..";
  my $back = $#names;
  my $tmp;
  while ($tmp = pop(@names)) {
    $tmp = clean_name($tmp,undef);
    $header = "<a href='".("../"x($back-$#names))."'>$tmp</a> : $header";
  }
  $header.=$this;

  print HTML <<END_OF_HEADER;
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title> 
      Album: $this
    </title>
    <meta NAME='Generator' CONTENT='$GEN_STRING'
    <meta NAME='Album_Path' CONTENT='$path'
  </head>
  <body bgcolor='white'>
  <table width='95%'>
    <tr>
      <td align='left'>
        <h2>$header</h2>
      </td>
      <td align='right'>
        <h1><a href='..'>Up</a></h1>
      </td>
    </tr>
  </table>
  <hr />
END_OF_HEADER

  if (-f "$dir/header.txt" && open(HEADER,"<$dir/header.txt")) {
    while(<HEADER>) { print HTML; }
    print HTML "<hr />\n";
  }
}

sub footer {
  my ($dir) = @_;
  if (-f "$dir/footer.txt" && open(FOOTER,"<$dir/footer.txt")) {
    while(<FOOTER>) { print HTML; }
    print HTML "<hr />\n";
  }
  my $date = localtime;
  print HTML <<END_OF_FOOTER;
    <font size='-1'>
      Generated by <a href='http://MarginalHacks.com/Hacks/album'>$PROGNAME</a>
      from <a href='http://MarginalHacks.com'>MarginalHacks</a>
      on $date
    </font>
  </body>
</html>
END_OF_FOOTER

}

#########################
# Table stuff
#########################
my $TABLE_COUNT;
sub start_table {
  $TABLE_COUNT = 0;
  print HTML "  <table cellspacing='10' width='95%'>\n";
  print HTML "    <tr>\n";
}

sub end_table {
  print HTML "       </td>\n";
  print HTML "    </tr>\n";
  print HTML "  </table>\n";
}

# Return true if we started a new row
sub new_element {
  my ($opt_H) = @_;
  my $new_row = 0;
  if ($TABLE_COUNT) {
    print HTML "      </td>\n";
    unless ($TABLE_COUNT % $opt_H->{'columns'}) {
      print HTML "    </tr><tr>\n";
      $new_row=1;
    }
  }
  print HTML "      <td ";
  print HTML "width='",(100/$opt_H->{'columns'}),"%' "
    if ($TABLE_COUNT < $opt_H->{'columns'});
  print HTML "valign='top'>\n";
  $TABLE_COUNT++;
}

##################################################
# Album generation
##################################################
sub clean_name {
  my ($name,$captions) = @_;

  return $captions->{$name} if ($captions->{$name});

  # No tags in filenames  :)
  $name =~ s/\</&lt;/g;

  # Remove postfixes
  $name =~ s/\.([^\.]{2,3}|tiff)$//;

  # Underbar = space
  $name =~ s/_/ /g;
  $name =~ s/\./ /g;

  # No paths
  $name =~ s|^.*/||g;

  $name;
}

# What's the filesize of a file?  (String format)
sub filesize($) {
  my ($file) = @_;
  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
      $atime,$mtime,$ctime,$blksize,$blocks) = stat($file);
  $size=int($size/102.4)/10;
  $size=int($size) if ($size>10);
  return "${size}k" if ($size<1024);
  $size=int($size/102.4)/10;
  return "${size}M" if ($size<1024);
  $size=int($size/102.4)/10;
  "${size}G";
}

# Is there some unknown HTML (that we didn't create?)
# If we know this HTML, get the full album path,
# in case we are only regenerating a branch of the full tree
my $PATH;
sub unknown_html {
  my ($file) = @_;

  my $mine;

  return 0 unless -f $file;
  return 0 if -z $file;
  open(FILE,$file) || return 1;
  while(<FILE>) {
    $mine = 1  if (/$OLD_GEN_RE/);	# Backwards compat
    $mine = 1  if (/meta\s+NAME='Generator'\s+CONTENT='$GEN_STRING'/i);
    $PATH = $1 if (/meta\s+NAME='Album_Path'\s+CONTENT='(.+)'/i);

    if ($mine && defined $PATH) {
      close(FILE);
      return 0;
    }
  }
  close(FILE);
  return $mine ? 0 : 1;
}

#########################
# Clean out unused images/files from the thumbnail directory
#########################
sub clean_thumb_dir {
  my ($opt_H,$dir,@pics) = @_;

  # Read the thumbnail directory
  opendir(DIR,$dir);
  my (@thumbs) = grep(!/^\.{1,2}$/, readdir(DIR));
  closedir(DIR);

  # Check each file to make sure it's a currently used thumbnail
  foreach my $thumb ( @thumbs ) {
    my $name = $thumb;
    $name  =~ s/\.$opt_H->{'type'}$//;	# Remove thumbnail postfix
    if (!grep(/^$name/,@pics)) {
      print "Remove unused thumbnail: $dir/$thumb\n";
      print STDERR "[$PROGNAME] Couldn't erase [$thumb]\n"
        unless unlink "$dir/$thumb"
    }
  }
}

#########################
# Read a captions file.
#   Caption files allow you to rename each image/directory in one file
#########################
sub read_captions {
  my ($opt_H,$dir) = @_;
  my %caps;
  my $caps = $opt_H->{'captions'};
  return unless ($caps);
  return unless (-r "$dir/$caps");
  if (!open(CAPS,"<$dir/$caps")) {
    print STDERR "[$PROGNAME] Couldn't read captions: [$dir/$caps]";
    return;
  }
  while(<CAPS>) {
    chomp;
    my ($filename,$caption)=split(/ /, $_, 2); #split on whitespace
    $caps{$filename}=$caption if ($filename && $caption);
  }
  close CAPS;
  \%caps;
}

#########################
# Make an album
#########################
sub do_album {
  my ($opt_H,$dir,@names) = @_;

  print STDERR "Album: $dir\n";

  #########################
  # Get images and subdirectories
  #########################
  opendir(DIR,$dir);
  my (@dir) = grep(!/^\.{1,2}$/, readdir(DIR));
  closedir(DIR);

  my @new_dirs = grep(-d "$dir/$_" && $_ ne $opt_H->{'dir'}, @dir);
  # Bad heuristic
  my @pics = grep(-f "$dir/$_" && !/\.html?$/, @dir);

  # Clean out thumbnail directory of images we don't have anymore
  clean_thumb_dir($opt_H,"$dir/$opt_H->{'dir'}",@pics)
    if ($opt_H->{'clean'} && -d "$dir/$opt_H->{'dir'}");

  #########################
  # Did we create the index file here?
  #########################
  return print STDERR "[$PROGNAME] Unknown HTML [$dir/$HTML] - skipping\n"
    if (unknown_html("$dir/$HTML"));
  # We may be using album to regenerate just a section of an album,
  # in this case, start with the PATH found in unknown_html()
  @names = split(/\//,$PATH) if (!$#names && $PATH);

  #########################
  # Read captions file
  #########################
  my $caps_H = read_captions($opt_H,$dir);
  $names[-1] = $caps_H->{$names[-1]} if ($caps_H->{$names[-1]});

  #########################
  # Write the html
  #########################
  open(HTML,">$dir/$HTML") || die("[$PROGNAME] Couldn't write html [$dir/$HTML]\n");
  header($dir,@names);

  #########################
  # Links to sub-albums
  #########################
  if (@new_dirs) {
    start_table($opt_H);
    new_element($opt_H);
    print HTML "<font size='+2'><i>More albums:</i></font>\n";
    foreach my $new ( sort @new_dirs ) {
      my $name = clean_name($new,$caps_H);
      new_element($opt_H);
      print HTML "<font size='+1'><a href='$new'>$name</a></font>\n";
    }
    end_table($opt_H);
    print HTML "<hr />\n";
  }

  #########################
  # Table of thumbnails
  #########################
  if (@pics) {
    start_table();
    foreach my $pic ( sort @pics ) {
      next if ($pic =~ /\.txt$/);	# Don't thumbnail captions  ;)
      next if ($pic =~ /~$/);		#   or emacs backup files
      next if ($pic eq $opt_H->{'captions'});	#   or the captions file
      my $name = clean_name($pic,$caps_H);
      # Image caption file (image_name.txt)
      my $img_cap = "$dir/$pic";  $img_cap =~ s/\.[^\.]+$//;  $img_cap.=".txt";
      my $size = filesize "$dir/$pic" if ($opt_H->{'sizes'});
      my $alt = $name;
      ($name,$alt) = ($1,$2) if ($name =~ /^(.*)\s*alt=\s*[\'\"]?(.+)[\'\"]?/i);

      new_element($opt_H);

      unless ($pic =~ /\.(mov|mpg|mpeg)$/) {
        # Thumbnail and picture info
        my $thumb = thumbnail($opt_H,"$dir/$pic");
        next unless ($thumb);
        # Ugly - remove path component from $thumb
        $thumb =~ s/^$dir\/?//;

        # The thumbnail
        print HTML "        <a href='$pic'>\n";
        print HTML "          <img width='$opt_H->{'x'}' height='$opt_H->{'y'}' border='0' src='$thumb' alt='$alt'><br \>\n";
        print HTML "          $name\n";
        print HTML "          <font size='-1'><i>[$size]</i></font>\n"
          if ($opt_H->{'sizes'});
        print HTML "        </a><br />\n";
      } else {
        # Movie clip - should we have a movie button?
        print HTML "        <font size='+1'><b>Movie Clip:</b></font>\n";
        print HTML "        <p>\n";
        print HTML "        <a href='$pic'>\n";
        print HTML "          $name\n";
        print HTML "          <font size='-1'><i>[$size]</i></font>\n";
        print HTML "        </a><br />\n";
      }
      if (-f $img_cap && open(IMG_CAP,"<$img_cap")) {
        print HTML "          <font size='-2'>\n";
        while(<IMG_CAP>) { print HTML; }
        print HTML "          </font>\n";
        close IMG_CAP;
      }
    }
    end_table();
    print HTML "<hr />\n";
  }

  footer($dir);
  close(HTML);

  #########################
  # Do all the subdirectories
  #########################
  foreach ( @new_dirs ) { do_album($opt_H,"$dir/$_",@names,$_); }
}

##################################################
# Thumbnail code
##################################################
sub thumb_name {
  my ($opt_H,$img) = @_;

  # Remove postfix
  $img =~ s/\.[^\.\/]+$//;

  return "${img}.tn.$opt_H->{'type'}" unless ($opt_H->{'dir'});

  my $dir = $opt_H->{'dir'};
  ($dir,$img) = ("$`/$opt_H->{'dir'}",$1) if ($img =~ m|/([^/]*)$|);

  (-d $dir) || mkdir($dir,0755) || die("[$PROGNAME] Couldn't make directory [$dir]\n");

  return "$dir/${img}.$opt_H->{'type'}"
}

sub get_size {
  my ($opt_H,$img) = @_;

  return (0,0) unless (-f $img);

  # Try to use identify if we have it
  if ($IDENTIFY && $opt_H->{'identify'}) {
    print STDERR "get_size() run: $IDENTIFY -ping $img\n" if ($MAIN::DEBUG);
    open(SIZE,"$IDENTIFY -ping $img 2>&1 |") ||
      die("[$PROGNAME] Couldn't run identify!  [$IDENTIFY]\n");
    while(<SIZE>) {
      print STDERR "get_size(): $_" if ($MAIN::DEBUG);
      if(/\s(\d+)x(\d+)(\s|\+)/) {
        close(SIZE);
        return ($1,$2);
      }
    }
    # I wish there was an easy way to tell if they had identify!
    die("[$PROGNAME] Can't get [$img] size from '$IDENTIFY -ping' output\n".
        "\tIf you don't have the $IDENTIFY tool, try the '-noidentify' option\n");
  }

  # Kludgy way to get size, but works with all images that convert reads
  print STDERR "get_size() run: $CONVERT -verbose $img /dev/null\n" if ($MAIN::DEBUG);
  open(SIZE,"$CONVERT -verbose $img /dev/null 2>&1 |") ||
    die("[$PROGNAME] Couldn't run convert!  [$CONVERT]\n");
  while(<SIZE>) {
    print STDERR "get_size(): $_" if ($MAIN::DEBUG);
    if(/\s(\d+)x(\d+)(\s|\+)/) {
      close(SIZE);
      return ($1,$2);
    }
  }
  die("[$PROGNAME] Can't get [$img] size from 'convert -verbose' output\n");
}

sub scale {
  my ($opt_H,$img,$x,$y,$new) = @_;

  print STDERR "scale() run: $CONVERT -verbose $img -sample ${x}x${y} $new\n"
    if ($MAIN::DEBUG);
  open(SIZE,"$CONVERT -verbose $img -sample ${x}x${y} $new 2>&1 |") ||
    die("[$PROGNAME] Couldn't run convert!  [$CONVERT]\n");
  while(<SIZE>) {
    print STDERR "scale(): $_" if ($MAIN::DEBUG);
    if(/=>(\d+)x(\d+)\s/) {
      close(SIZE);
      return ($1,$2);
    }
  }
  close(SIZE);

  # Sometimes convert doesn't give us the new size information
  #print STDERR "[$PROGNAME] Error scaling $img\n";
  get_size($opt_H,$new);
}

sub crop {
  my ($img,$x,$y,$off_x,$off_y,$new) = @_;
  print STDERR "crop() run: $CONVERT $img -crop ${x}x${y}+${off_x}+${off_y} $new\n"
    if ($MAIN::DEBUG);
  system("$CONVERT $img -crop ${x}x${y}+${off_x}+${off_y} $new");
  return unless ($?);
  print STDERR "[$PROGNAME] Error cropping $img\n";
}

#########################
# Generate the thumbnail
#########################
sub thumbnail {
  my ($opt_H,$img) = @_;

  print STDERR "\nIMAGE: $img\n" if ($MAIN::DEBUG);

  my ($thumb) = thumb_name($opt_H,$img);

  # Don't regenerate thumbs if we don't need to.
  return $thumb if (-f $thumb && !$opt_H->{'force'} && -M $thumb < -M $img);

  my ($x,$y) = get_size($opt_H,$img);

  # Which way do we need to shrink?  convert will scale down w/ aspect
  # as much as is needed to *fit* inside the geometry we give it
  # Hack:  Assume the image is larger than a thumbnail
  my ($scale_x,$scale_y) = ($opt_H->{'x'},$opt_H->{'y'});
  if ($opt_H->{'crop'}) {
    if ( $x/$opt_H->{'x'} < $y/$opt_H->{'y'} ) {
      # Make vertical bigger so that we don't scale horizontal past $opt_H->{'x'}
      $scale_y = $y;
    } else {
      $scale_x = $x;
    }
  }
  ($x,$y) = scale($opt_H,$img,$scale_x,$scale_y,$thumb);
  next unless $x;

  if ($opt_H->{'crop'}) {
    # Now crop the other dimension
    my ($off_x,$off_y) = (0,0);
    if ( $x > $opt_H->{'x'} ) {
      $off_x = int(($x-$opt_H->{'x'})/2);
    }
    if ($y > $opt_H->{'y'}) {
      $off_y = int(($y-$opt_H->{'y'})/2);
    }
    crop($thumb,$opt_H->{'x'},$opt_H->{'y'},$off_x,$off_y,$thumb)
      unless ($x==$opt_H->{'x'} && $y==$opt_H->{'y'});
  }

  $thumb;
}

##################################################
# Main code
##################################################
sub main {
  my ($opt_H,$dir) = parse_args();

  # Get the true basename (in case they use '..' or some such)
  my $pwd=`pwd`; chomp($pwd);
  chdir($dir) || usage("Couldn't find [$dir]");
  my $name=`pwd`;  chomp($name);
  chdir($pwd);
  $name =~ s|.*/||;


  do_album($opt_H,$dir,$name);
}
main();

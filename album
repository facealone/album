#!/usr/bin/perl
# Filename:	album
# Author:	David Ljung Madison <DaveSource.com>
# See License:	http://MarginalHacks.com/License
# Version:	2.17
# Description:	Makes a photo album
use strict;

umask 022;	# 0755

##################################################
# Setup the variables
##################################################
my $PROGNAME = $0;
$PROGNAME =~ s|.*/||;

my $CONVERT	= "convert";
my $IDENTIFY	= "identify";	# Undef if you don't have identify

my $EPERL	= "eperl";	# Only needed for templates

# Default directory page
my $HTML	= ".html";
my $DEFAULT_INDEX = "index";		# Don't need to specify this index
my $HEADER	= "header.txt";
my $FOOTER	= "footer.txt";
my $NO_ALBUM	= ".no_album";		# Don't run album on these directories
my $HIDE_ALBUM	= ".hide_album";	# Don't even show these directories
my $NOT_IMG	= $NO_ALBUM;		# Postfix for files that aren't images

my %DEFAULTS	= (
	# Thumbnail stuff
	'x'		=> 133,		# Size of thumbnails
	'y'		=> 100,
	'crop'		=> 1,		# Crop or just scale?
	'force'		=> 0,		# Force thumbnail generation
	'type'		=> "gif",	# Thumbnail image type
	'dir'		=> "tn",	# Thumbnail directory
	'known_images'	=> 0,		# I'd rather keep my album clean
	'sample'	=> 0,		# -sample:-geometry :: fast:better

	# Album stuff
	'medium'	=> "",		# Make medium size pictures?
	'image_pages'	=> 1,		# Page per image
	'index'		=> "index",	# Default index
	'body'		=> "<body bgcolor='white'>",		# <body> tag
	'top'		=> "..",	# The "Back" for the top album
	'columns'	=> 4,		# Number of images per row
	'file_sizes'	=> 0,		# Show image file sizes
	'image_sizes'	=> 0,		# Get image sizes (width*height)
	'clean'		=> 0,		# Clean garbage out of thumbnail dir?
	'captions'	=> "captions.txt",	# Captions filename?
	'fix_urls'	=> 1,		# Convert spaces to %20 in URLs?
	'all'		=> 0,		# Do not hide .directories

	# deprecated, it's automated now
	'identify'	=> 1,		# Use identify or convert for get_size?

	'theme'		=> "",		# So that -no_theme works, ignored.
	);

# As of "ImageMagick 4.2.9 99/09/01"
# May not be the same as your version of convert, but damn it's alot!
my $IMAGE_TYPES	=
	"AVS|BMP|BMP24|CMYK|DCM|DCX|DIB|EPDF|EPI|EPS|EPS2|EPSF|EPSI|EPT|FAX".
	"FITS|G3|GIF|GIF87|GRADATION|GRANITE|GRAY|HDF|HISTOGRAM|ICB|ICC|ICO".
	"IPTC|JPG|JPEG|JPEG24|LABEL|LOGO|MAP|MATTE|MIFF|MNG|MONO|MTV|NULL|P7".
	"PBM|PCD|PCDS|PCL|PCT|PCX|PDF|PIC|PICT|PICT24|PIX|PLASMA|PGM|PM|PNG".
	"PNM|PPM|PREVIEW|PS|PS2|PS3|PSD|PTIF|PWP|RAS|RGB|RGBA|RLA|RLE|SCT|SFW".
	"SGI|SHTML|STEGANO|SUN|TEXT|TGA|TIF|TIFF|TIFF24|TILE|TIM|TTF|TXT|UIL".
	"UYVY|VDA|VICAR|VID|VIFF|VST|X|XBM|XC|XPM|XV|XWD|YUV";

#########################
# abs_path
#########################
use Cwd 'abs_path';
# If you don't have the Cwd module, use this:
#sub abs_path {
#  my ($dir) = @_;
#  my $pwd=`pwd`; chomp($pwd);
#  chdir($dir) || usage("Couldn't find [$dir]");
#  my $name=`pwd`;  chomp($name);
#  chdir($pwd);
#  $name;
#}

#########################
# URLs for these scripts
#########################
my $HOME	= "http://MarginalHacks.com/";
my $ALBUM_URL	= "http://MarginalHacks.com/Hacks/album";
my $GEN_STRING	= "album http://MarginalHacks.com/";
my $OLD_GEN_RE	= "Generated by <a href=.+>$PROGNAME</a> and <a href=.+>thumb</a>";

##################################################
# Usage
##################################################
sub default {
  my $d = $DEFAULTS{$_[0]};
  print $d==1 ? " [ON]\n" : $d ? " [$d]\n" : "\n";
}
my $ARG_THEME;	# Themes can specify args - show where they came from
sub usage {
  my $msg;
  foreach $msg (@_) { print "ERROR:  $msg\n"; }
  print "\tOption from theme: [$ARG_THEME]\n" if $ARG_THEME;
  print "\n";
  print "Usage:\t$PROGNAME [-d] [--scale_opts .. --] [options] <dir>\n";
  print "\tMakes a photo album\n";
  print "\n";
  print "\tAll boolean options can be turned off with '-no_option'\n";
  print "\t(Some are default on, defaults shown in [brackets])\n";
  print "\n";
  print "Album Options:\n";
  print "\t-d                Set debug mode\n";
  print "\t-medium <geom>    Generate medium size images"; default("medium");
  print "\t-image_pages      Create a page for each image"; default("image_pages");
  print "\t-columns          Number of image columns"; default("columns");
  print "\t-file_sizes       Show image file sizes"; default("file_sizes");
  print "\t-image_sizes      Get image size (width*height) (for some themes)"; default("image_sizes");
  print "\t-clean            Remove unused thumbnails"; default("clean");
  print "\t-captions         Specify captions filename"; default("captions");
  print "\t-fix_urls         Convert spaces to %20 in URLs"; default("fix_urls");
  print "\t-known_images     Only include known image types"; default("known_images");
  print "\t-body             Specify <body> tags for default output\n";
  print "\t-all              Do not hide directories starting with '.'\n";
  print "\n";
  print "Thumbnail Options:\n";
  print "\t-geometry=<X>x<Y> Size of thumbnail  [${DEFAULTS{'x'}}x${DEFAULTS{'y'}}]\n";
  print "\t-type             Thumbnail type (gif, jpg, tiff,...)"; default("type");
  print "\t-crop             Crop the image to fit thumbnail size\n";
  print "\t                   else aspect will be maintained"; default("crop");
  print "\t-dir              Thumbnail directory"; default("dir");
  print "\t-force            Force overwrite of existing thumbnails\n";
  print "\t                   else they are only written when changed"; default("force");
  print "\t-sample           convert -sample for thumbnails (faster, low quality)"; default("sample");
  print "\t--scale_opts      List of convert options, end with '--'\n";
  print "\t                  (Also --med_scale_opts and --full_scale_opts..)\n";
  print "\n";
  print "Theme Options:\n";
  print "\t-theme <dir>      Specify a theme directory\n";
  print "\t-no_theme         Ignore album's previous theme settings\n";
  print "\n";
  print "Author:  David Ljung Madison, $HOME\n";
  print "\n";
  exit -1;
}

sub set_size {
  my ($opt_H,$size) = @_;
  return ($opt_H->{'x'},$opt_H->{'y'}) = ($1,$2) if ($size =~ /^(\d+)x(\d+)$/);
  usage("Can't understand geometry [$size]");
}

# Theme directories contain album.th and image.th
sub get_themes {
  my ($opt_H,$dir) = @_;

  $opt_H->{'theme'} = abs_path($dir);
  $ARG_THEME = $dir;

  my $dir = $opt_H->{'theme'};

  my @new_opts;	# Options specified by themes

  # If it's a directory, look for "image.th" and "album.th"
  usage("-theme needs to specify a directory [$dir]") unless (-d $dir);
  my $found = 0;
  if (-f "$dir/album.th") {
    $found++;
    $opt_H->{'album.th'} = "$dir/album.th";
    push(@new_opts,get_theme($opt_H,'album.th'));
  }
  if (-f "$dir/image.th") {
    $found++;
    $opt_H->{'image.th'} = "$dir/image.th";
    push(@new_opts,get_theme($opt_H,'image.th'));
  }
  usage("No themes found in [$dir]") unless $found;
  return @new_opts;
}

# Read in a whole template/theme file
# Check for Meta() and Credit()
# (These tags are actually needed for proper operation,
#  not just my ego gratification!  Please don't override!)
sub get_theme {
  my ($opt_H,$which) = @_;

  my $file = $opt_H->{$which};
  my $data = "$which.data";
  undef $opt_H->{$data};	# In case we've specified themes twice..

  my @new_opts;
  my $top = 1;	# Options can only be specified at the top of the file
  my $start_line = 1;

  open(TEMP,"<$file") || usage("Couldn't read theme [$file]");
  my ($in_head,$saw_meta,$saw_credit);
  while (<TEMP>) {
    if ($top && /^\s*(#c)?\s*(\/\/)?\s*options?:\s*(\S.*)/i) {
      my $opt = $3;  $opt =~ s/\s+$//g;
      push(@new_opts,split(/\s+/,$opt));
      $start_line = $.+1;
      next;
    }
    $top = 0;
    push(@{$opt_H->{$data}},$_);
    $in_head=1 if (/<head>/);
    if (/Meta\(\)/) {
      usage("Meta() must be inside <head>...</head>") if (!$in_head);
      $saw_meta=1;
    }
    $in_head=0 if (/<\/head>/);
    $saw_credit=1 if (/Credit\(\)/);
  }
  close(TEMP);

  usage("You need to call Meta() inside <head>..</head> of [$file]") unless $saw_meta;
  usage("You need to call Credit() in your theme [$file]") unless $saw_credit;

  $opt_H->{"$which.line"} = $start_line;

  @new_opts;
}

sub parse_args {
  my $dir;
  my %opt;

  # Defaults
  %opt = %DEFAULTS;

  my @theme_args;	# We can get args from the theme as well

  push(@ARGV,".") unless @ARGV;
  while (@ARGV || @theme_args) {
    undef $ARG_THEME unless (@theme_args);
    my $arg=shift(@theme_args) || shift(@ARGV);
    if ($arg =~ /^-h$/) { usage(); }
    if ($arg =~ /^-(no_?)?d$/) { $MAIN::DEBUG = $1?0:1; next; }
    if ($arg =~ /^-g(eom(etry)?)?(=(.+))?$/) { set_size(\%opt,$4 ? $4 : (shift(@theme_args) || shift(@ARGV))); next; }
    if ($arg =~ /^-theme(=(.+))?$/) {
      @theme_args = get_themes(\%opt, ($2?$2:(shift(@theme_args) || shift(@ARGV))));
      next;
    }
    if ($arg =~ /^--(full_|med_|)scale_opts(=(.+))?$/) {
      my $scale_opts = "${1}scale_opts";
      # --scale_opts=<opt>
      if ($3) {
        $opt{$scale_opts} .= "$3 ";

      # Theme:  --scale_opts <opt> <opt> --
      } elsif (@theme_args) {
        $opt{$scale_opts} .= shift(@theme_args)." "
          while (@theme_args && $theme_args[0] ne "--");
        usage("Missing -- at end of $scale_opts") unless shift(@theme_args);

      # ARGV:  --scale_opts <opt> <opt> --
      } else {
        $opt{$scale_opts} .= shift(@ARGV)." "
          while (@ARGV && $ARGV[0] ne "--");
        usage("Missing -- at end of $scale_opts") unless shift(@ARGV);
      }

      next;
    }
    if ($arg =~ /^-(no_?)?(.+)$/) {
      my ($no,$opt) = ($1,$2);
      usage("Unknown option: $opt") unless (defined $DEFAULTS{$opt});
      # Options that take arguments
      if ($opt =~ /^(medium|dir|type|columns|captions|index|top|body)$/) {
        usage("Option [$opt] can't be -no, it needs an argument") if ($no);
        my $val = (shift(@theme_args) || shift(@ARGV));
        if ($opt eq "index" && $val eq $DEFAULT_INDEX) {
          undef $DEFAULT_INDEX;
        } else {
          $opt{$opt} = $val;
        }
      } elsif ($opt eq "theme") {
        $opt{'notheme'} = 1;
      } else {
        $opt{$opt} = $no ? 0 : 1;
        # Need to override image themes
        $opt{'no_image_pages'} if ($opt eq "image_pages" && $no);
      }
      next;
    }
    usage("Can't find directory $arg") unless (-d $arg);
    usage("Too many directories: $arg and $dir") if ($dir);
    $dir=$arg;

    # Did we specify a theme last time?
    unless ($opt{'notheme'} || $opt{'theme'}) {
      my $theme = previous_build_theme(\%opt,$dir);
      @theme_args = get_themes(\%opt,$theme) if ($theme);
    }
  }
  continue {
    # We're about done with args, get default (and make sure we get theme args)
    push(@ARGV,".") unless ($dir || @ARGV || @theme_args);
  }

  # Allow -no_image_pages to override themes
  if ($opt{'no_image_pages'}) {
    $opt{'image.th'}=0;
    $opt{'image_pages'}=0;
  }
  $opt{'image_pages'}=1 if ($opt{'image.th'});

  # -medium needs image pages
  $opt{'image_pages'}=1 if ($opt{'medium'});

  # We'll add the .html flag
  $opt{'index'} =~ s/\Q$HTML\E$//;

  $dir =~ s|/$||;	# Little cleanup
  (\%opt,$dir);
}

##################################################
# HTML
##################################################
sub header {
  my ($opt_H,$image_page,$dir,@parents) = @_;

  my @names = @parents;

  my $path = join("/",@names);
  my $this = pop(@names);
  my $header;
  my $back = $#names;
  my $index = ("$opt_H->{'index'}" eq "$DEFAULT_INDEX") ? "" : "$opt_H->{'index'}$HTML";
  while ($_ = pop(@names)) {
    $header = "<a href='".("../"x($back-$#names))."$index'>$_</a> : $header";
  }
  $header.=$this;

  my $Up = $image_page ? "Back" : "Up";
  my $UpUrl = "../" . ($opt_H->{'index'} eq $DEFAULT_INDEX ? "" : "$opt_H->{'index'}$HTML");
  $UpUrl = $opt_H->{'top'} unless ($#parents || $image_page);

  print ALBUM <<END_OF_HEADER;
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title> 
      Album: $this
    </title>
    <meta NAME='Generator' CONTENT='$GEN_STRING'>
    <meta NAME='Album_Path' CONTENT='$path'>
  </head>
  $opt_H->{'body'}
  <table width='95%'>
    <tr>
      <td align='left'>
        <h2>$header</h2>
      </td>
      <td align='right'>
        <h1><a href='$UpUrl'>$Up</a></h1>
      </td>
    </tr>
  </table>
  <hr />
END_OF_HEADER

  if (-f "$dir/$HEADER" && open(HEADER,"<$dir/$HEADER")) {
    while(<HEADER>) { print ALBUM; }
    print ALBUM "<hr />\n";
  }
}

sub footer {
  my ($dir) = @_;
  if (-f "$dir/$FOOTER" && open(FOOTER,"<$dir/$FOOTER")) {
    while(<FOOTER>) { print ALBUM; }
    print ALBUM "<hr />\n";
  }
  my $date = localtime;
  print ALBUM <<END_OF_FOOTER;
    <font size='-1'>
      Generated by <a href='http://MarginalHacks.com/Hacks/album'>$PROGNAME</a>
      from <a href='http://MarginalHacks.com'>MarginalHacks</a>
      on $date
    </font>
  </body>
</html>
END_OF_FOOTER

}

##################################################
# Album generation
##################################################
# Nice name for printing
sub clean_name {
  my ($name,$captions) = @_;

  return $captions->{$name}{name} if ($captions->{$name});

  # No tags in filenames  :)
  $name =~ s/\</&lt;/g;

  # Remove postfixes
  $name =~ s/\.($IMAGE_TYPES)$//i;
  $name =~ s/\Q$HTML\E$//i;

  # Remove thumbnail cropping directives
  $name =~ s/CROP(top|bottom|left|right)$//;

  # Underbar = space
  $name =~ s/_/ /g;
  $name =~ s/\./ /g;

  # No paths
  $name =~ s|^.*/||g;

  $name;
}

# What's the filesize of a file?  (String format)
sub filesize($) {
  my ($file) = @_;
  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
      $atime,$mtime,$ctime,$blksize,$blocks) = stat($file);
  $size=int($size/102.4)/10;
  $size=int($size) if ($size>10);
  return "${size}k" if ($size<1024);
  $size=int($size/102.4)/10;
  return "${size}M" if ($size<1024);
  $size=int($size/102.4)/10;
  "${size}G";
}

# Is there some unknown HTML (that we didn't create?)
# If we know this HTML, get the full album path,
# in case we are only regenerating a branch of the full tree
my $PATH;
sub unknown_html {
  my ($opt_H,$dir) = @_;

  return 1 if (-f "$dir/$NO_ALBUM");

  my $file = "$dir/$opt_H->{'index'}$HTML";
  return 0 unless -f $file;
  return 0 if -z $file;

  my $mine;
  open(FILE,"<$file") || return 1;
  while(<FILE>) {
    $mine = 1  if (/$OLD_GEN_RE/);	# Backwards compat
    $mine = 1  if (/meta\s+NAME='Generator'\s+CONTENT='$GEN_STRING'/i);
    $PATH = $1 if (/meta\s+NAME='Album_Path'\s+CONTENT='(.+)'/i);

    if ($mine && defined $PATH) {
      close(FILE);
      return 0;
    }
  }
  close(FILE);
  return 0 if $mine;
  print STDERR "[$PROGNAME] Unknown HTML [$file] - skipping\n";
  return 1;
}

# Return theme if previously defined
sub previous_build_theme {
  my ($opt_H,$dir) = @_;

  my $file = "$dir/$opt_H->{'index'}$HTML";
  open(FILE,"<$file") || return undef;
  while(<FILE>) {
    if (/meta\s+NAME='Album_Theme'\s+CONTENT='(.+)'/i) {
      close(FILE);
      return $1 if (-d $1);
      print STDERR "[$PROGNAME] Warning: Couldn't find previous theme in $file: $1\n";
      return undef;
    }
  }
  close(FILE);
  undef;
}

#########################
# Clean out unused images/files from the thumbnail directory
#########################
sub clean_thumb_dir {
  my ($opt_H,$dir,@pics) = @_;

  # Read the thumbnail directory
  opendir(DIR,$dir);
  my (@files) = grep(!/^\.{1,2}$/, readdir(DIR));
  closedir(DIR);

  # Check each file to make sure it's a currently used thumbnail or image_page
  foreach my $file ( @files ) {
    my $remove;
    my $name = $file;
    if ($name =~ s/\Q$HTML\E$//) {
      $remove = "unused image page"
        unless ($opt_H->{'image_pages'} && grep($_ eq $name, @pics));
    } elsif ($name  =~ /\.med\./) {
      $name = $`.".".$';
      $remove = "unused medium image"
        unless ($opt_H->{'medium'} && grep($_ eq $name, @pics));
    } elsif ($name  =~ /\.$opt_H->{'type'}$/) {
      # Thumbnail?
      $name = $`;
      $remove = "unused thumbnail" unless (grep(/^\Q$name.\E/, @pics));
    } else {
      $remove = "unknown file";
    }
    if ($remove) {
      print "Remove $remove: $dir/$file\n";
      print STDERR "[$PROGNAME] Couldn't erase [$file]\n"
        unless unlink "$dir/$file"
    }
  }
}

#########################
# Quote URLs to avoid errors
#########################
sub quote {
  my ($path,$opt_H) = @_;
  $path =~ s/'/%27/g;	# Convert ' to %27
  $path =~ s/"/%22/g;	# Convert " to %22
  $path = "'$path'";	# And quote the rest
  return $path unless ($opt_H && $opt_H->{'fix_urls'});
  # Should probably correct more than just whitespace
  $path =~ s/(\s)/"%".sprintf("%2.2x",ord($1))/eg;
  $path;
}

#########################
# Read a captions file.
#   Caption files allow you to rename each image/directory in one file
#########################
sub read_captions {
  my ($opt_H,$dir) = @_;
  my %caps;
  my $caps = $opt_H->{'captions'};
  return unless ($caps);
  return unless (-r "$dir/$caps");
  if (!open(CAPS,"<$dir/$caps")) {
    print STDERR "[$PROGNAME] Couldn't read captions: [$dir/$caps]";
    return;
  }
  my @caps = <CAPS>;
  close CAPS;
  my $split_tabs = grep(/\t/, @caps) ? 1 : 0;
  my $num = 1;
  foreach ( @caps ) {
    chomp;
    my ($file,$name,$cap,$alt)=
      $split_tabs ? split(/\t+/, $_, 4) : split(/\s*?:\s*?/, $_, 4);
    $name=$file if (!$name && $cap);
    next unless $file && $name;
    $caps{$file}{name}=$name;
    $caps{$file}{cap}=$cap if $cap;
    $caps{$file}{alt}=$alt if $alt;
    $caps{$file}{num}=$num++;
  }
  \%caps;
}

# Sort according to order found in optional captions file
sub caption_order {
  my ($caps_H,$a,$b) = @_;
  my $an = $caps_H->{$a} && $caps_H->{$a}{num};
  my $bn = $caps_H->{$b} && $caps_H->{$b}{num};

  return $an <=> $bn if ($an && $bn);
  return ($a cmp $b);

#  # This code will put captioned images above non-captioned images
#  if ($an) {
#    return $bn ? ($an <=> $bn) : -1;
#  } else {
#    return $bn ? 1 : ($a cmp $b);
#  }
}

#########################
# Template/theme stuff
#########################
sub setup_output {
  my ($opt_H,$out,$theme) = @_;

  if ($theme) {
    # We pipe into eperl stdin
    open(ALBUM,"|$EPERL -P - -o \Q$out\E") ||
      die("[$PROGNAME] Couldn't start $EPERL to write [$out]\n");
  } else {
    # Just write a file
    open(ALBUM,">$out") ||
      die("[$PROGNAME] Couldn't write html [$out]\n");
  }
}

sub close_output {
  my ($opt_H,$theme) = @_;
  close(ALBUM);
  my $ret = $?;
  return unless $theme;
  return unless $ret;

  my $exit = $ret >> 8;
  my $int  = $ret & 127; 
  my $core = $ret & 128;
  print STDERR "[$PROGNAME] eperl theme returned error [$exit]\n" if ($exit);
  print STDERR "[$PROGNAME] eperl theme INTERRUPTED\n" if ($int);
  print STDERR "[$PROGNAME] eperl theme (Core dump)\n" if ($core);
  die("\n");
}

# Take a scalar/array/hash and turn it into perl statements to set the array
sub perl_quote_scalar {
  my ($str) = @_;
  $str =~ s/'/\\'/g;
  "'$str'";
}
sub perl_quote_array {
  my ($a) = @_;
  my $str = "\t(\n";
  foreach my $el ( @$a ) {
    $str .= "\t".perl_quote_scalar($el).",\n";
  }
  $str."\t)";
}
sub perl_quote_hash {
  my ($h) = @_;
  my $str = "\t(\n";
  foreach my $key ( keys %$h ) {
    next if ref($h->{$key});	# Only quote scalars
    $str .= "\t".perl_quote_scalar($key).
            "\t=> ".perl_quote_scalar($h->{$key}).",\n";
  }
  $str."\t)";
}

# (Writing perl with perl is a bitch!  Quoting nightmare!)
sub convert_data_to_eperl {
  my ($opt_H,$data_H) = @_;

  # Support routines are basically the same for the main
  # index and all the image pages, so only convert once:
  return if ($data_H->{'eperl'} && @{$data_H->{'eperl'}});

  push(@{$data_H->{'eperl'}},"#change file: 1 \"album support\"\n");

  # Set data up to be transferred to eperl
  # Quote arrays
  push(@{$data_H->{'eperl'}},"<:\n");
  foreach my $key ( keys %$data_H ) {
    next if ($key eq "eperl");
    my $NAME = uc($key);
    if (ref($data_H->{$key}) eq "ARRAY") {
      push(@{$data_H->{'eperl'}}, "my \@$NAME = ".perl_quote_array($data_H->{$key}).";\n");
    } else {
      push(@{$data_H->{'eperl'}}, "my \$$NAME = ".perl_quote_scalar($data_H->{$key}).";\n");
    }
  }
  push(@{$data_H->{'eperl'}},'my %OPTIONS = '.perl_quote_hash($opt_H).";\n");
  push(@{$data_H->{'eperl'}},":>//\n");

  # Write the support routines to eperl
  my $TN_GEOM = $opt_H->{'crop'} ?
                  "width='$opt_H->{'x'}' height='$opt_H->{'y'}'" : "";

  push(@{$data_H->{'eperl'}},<<SUPPORT);
<:
# Album name
my \$ALBUM_NAME = \$PARENT_ALBUMS[-1];
sub pAlbum_Name { print \$ALBUM_NAME; }
my \$IMAGE_PAGE = 0;
sub Image_Page { \$IMAGE_PAGE; }
sub Album_Filename { \$ALBUM_FILENAME; }

# Header/footer
sub pFile {
  my (\$f) = \@_;
  return 0 unless \$f;
  return 0 unless (-r \$f);
  return 0 unless open(FILE,"<\$f");
  while(<FILE>) { print; }
  close FILE;
  return 1;
}
sub isHeader { return (-r "\$DIR/$HEADER") ? 1 : 0; }
sub pHeader { pFile("\$DIR/$HEADER"); }
sub isFooter { return (-r "\$DIR/$FOOTER") ? 1 : 0; }
sub pFooter { pFile("\$DIR/$FOOTER"); }

# Get any of the command line options
sub Get_Opt { return \$OPTIONS{\$_[0]}; }

# Main index page (probably just default of "")
sub Index { ("$opt_H->{'index'}" eq "$DEFAULT_INDEX") ? "" : "$opt_H->{'index'}$HTML"; }
# Go back to a previous index, or just ".." for the top page of the album
sub Back { (\$#PARENT_ALBUMS || Image_Page()) ? "../".Index() : "$opt_H->{'top'}"; }

# Parent albums
my \$PARENT_ALBUM_CNT = 0;
sub Parent_Albums { (\$PARENT_ALBUM_CNT <= \$#PARENT_ALBUMS) ? 1 : 0; }
sub Parent_Album {
  return "" unless Parent_Albums();
  if (\$PARENT_ALBUM_CNT == \$#PARENT_ALBUMS) {
    return \$PARENT_ALBUMS[\$PARENT_ALBUM_CNT] unless Image_Page();
    return "<a href='../".Index()."'>\$PARENT_ALBUMS[\$PARENT_ALBUM_CNT]</a>";
  }
  my \$str = "<a href='";
  \$str .=   "../"x(Parent_Albums_Left() - (Image_Page()?0:1));
  \$str .=   Index();
  \$str .=   "'>\$PARENT_ALBUMS[\$PARENT_ALBUM_CNT]</a>";
  \$str;
}
sub pParent_Album { print Parent_Album(); }
sub Parent_Albums_Left { \$#PARENT_ALBUMS + 1 - \$PARENT_ALBUM_CNT; }
sub Parent_Album_Cnt { \$PARENT_ALBUM_CNT+1; }
sub Next_Parent_Album { \$PARENT_ALBUM_CNT++; }
sub pJoin_Parent_Albums {
  while(Parent_Albums()) {
    pParent_Album();
    Next_Parent_Album();
    print \$_[0] if (Parent_Albums());
  }
}

# Child albums
my \$CHILD_ALBUM_CNT = 0;
sub Child_Albums { (\$CHILD_ALBUM_CNT <= \$#CHILD_ALBUM_NAMES) ? 1 : 0; }
sub pChild_Album {
  print "<a href=\$CHILD_ALBUM_URLS[\$CHILD_ALBUM_CNT]>";
  print "\$CHILD_ALBUM_NAMES[\$CHILD_ALBUM_CNT]</a>";
}
sub Child_Album_URL { \$CHILD_ALBUM_URLS[\$CHILD_ALBUM_CNT]; }
sub Child_Album_Name { \$CHILD_ALBUM_NAMES[\$CHILD_ALBUM_CNT]; }
sub Child_Album_Cnt { \$CHILD_ALBUM_CNT+1; }
sub Child_Albums_Left { \$#CHILD_ALBUM_NAMES + 1 - \$CHILD_ALBUM_CNT; }
sub Next_Child_Album { \$CHILD_ALBUM_CNT++; }

# Images
my \$IMAGE_CNT = 0;
my \$THIS_IMAGE = 0;
sub Images { (\$IMAGE_CNT <= \$#IMAGE_NAMES) ? 1 : 0; }
sub Image_Src { \$IMAGE_MEDIUMS[\$IMAGE_CNT] || Image_URL(); }
sub pImage_Src {
  print "<img src=",Image_Src()," border='0' alt=",Image_Alt();
  print " width='",Image_Width(),"'" if Image_Width();
  print " height='",Image_Height(),"'" if Image_Height();
  print ">";
}
sub pImage_Thumb_Src {
  print "<img src=",Image_Thumb()," border='0' alt=",Image_Alt();
  #print " width='$opt_H->{'x'}' height='$opt_H->{'y'}' border='0'>";
  print " $TN_GEOM border='0'>";
}
sub pImage {
  return undef unless Images();
  print "<a href=".Image_URL().">";
  pImage_Thumb_Src() if (Image_Is_Pic());
  if (!defined \$_[0] || \$_[0]) {
    print "<br />\n";
    print Image_Name();
  }
  print "</a>";
}
# In the image page we use the real URL (back one dir)
# Otherwise we use the url to the image page (or just the image)
sub Image_URL { Image_Page() ? \$IMAGE_IMAGE_URLS[\$IMAGE_CNT] : \$IMAGE_URLS[\$IMAGE_CNT]; }
sub Image_Page_URL { \$IMAGE_PAGE_URLS[\$IMAGE_CNT]; }
sub Image_Name { \$IMAGE_NAMES[\$IMAGE_CNT]; }
sub Image_Thumb { Image_Page() ? \$IMAGE_PAGE_THUMBS[\$IMAGE_CNT] : \$IMAGE_THUMBS[\$IMAGE_CNT]; }
sub Image_Is_Pic { \$IMAGE_IS_PIC[\$IMAGE_CNT]; }
sub Image_Alt { \$IMAGE_ALTS[\$IMAGE_CNT]; }
sub Image_Filesize { \$IMAGE_FILESIZES[\$IMAGE_CNT]; }
sub Image_Width { \$IMAGE_WIDTHS[\$IMAGE_CNT]; }
sub Image_Height { \$IMAGE_HEIGHTS[\$IMAGE_CNT]; }
sub Image_Cnt { \$IMAGE_CNT+1; }
sub Images_Left { \$#IMAGE_NAMES + 1 - \$IMAGE_CNT; }
sub Next_Image { \$IMAGE_CNT++; }
sub pImage_Caption {
  return if pFile(\$IMAGE_CAPTION_FILES[\$IMAGE_CNT]);
  print \$IMAGE_CAPTIONS[\$IMAGE_CNT];
}

# For image pages
sub Image_Prev { \$THIS_IMAGE ? \$THIS_IMAGE-1 : \$#IMAGE_NAMES; }
sub Image_Next { \$THIS_IMAGE==\$#IMAGE_NAMES ? 0 : \$THIS_IMAGE+1; }
sub Set_Image_Prev { \$IMAGE_CNT = Image_Prev(); }
sub Set_Image_Next { \$IMAGE_CNT = Image_Next(); }
sub Set_Image_This { \$IMAGE_CNT = \$THIS_IMAGE; }

# Meta tag needed for regenerating portions of the album tree.
sub Meta {
  print "<meta NAME='Generator' CONTENT='$GEN_STRING'>\\n";
  print "<meta NAME='Album_Path' CONTENT='\$ALBUM_PATH'>\\n";
  print "<meta NAME='Album_Theme' CONTENT='\$OPTIONS{theme}'>\\n";
  print "<meta NAME='Prev_Image' CONTENT='",\$PICS[Image_Prev()],"'>\\n";
  print "<meta NAME='Next_Image' CONTENT='",\$PICS[Image_Next()],"'>\\n";
  \$CALLED_META=1;
}
sub Credit {
  print "Generated by <a href='http://MarginalHacks.com/Hacks/album'>$PROGNAME</a>\\n";
  print "from <a href='http://MarginalHacks.com'>MarginalHacks</a>\\n";
  \$CALLED_CREDIT=1;
}
sub Album_End {
  die("ERROR: Didn't call Meta() in <head>!\n") unless \$CALLED_META;
  die("ERROR: Didn't call Credit()!\n") if (!\$CALLED_CREDIT && !Image_Page());
}

:>//
SUPPORT

  push(@{$data_H->{'end_eperl'}},"<:Album_End():>");
}

sub write_theme {
  my ($opt_H,$data_H) = @_;

  convert_data_to_eperl($opt_H,$data_H);

  setup_output($opt_H,$data_H->{'album_filename'},1);

  # Write the support data/functions
  print ALBUM @{$data_H->{'eperl'}};

  # Then write the theme
  print ALBUM "#change file: $opt_H->{'album.th.line'} \"$opt_H->{'album.th'}\"\n";
  print ALBUM @{$opt_H->{"album.th.data"}};

  # End support
  print ALBUM @{$data_H->{'end_eperl'}};

  close_output($opt_H,1);
}

sub dependency_changed {
  my ($file,@dependencies) = @_;
  return 1 unless -f $file;
  my $file_mod = -M $file;
  foreach my $dep ( @dependencies ) {
    next unless -f $dep;
    my $mod = -M $dep;
    return 1 if $mod <= $file_mod;
  }
  return 0;
}

sub prev_next_theme_path_changed {
  my ($file,$prev,$next,$theme,$path) = @_;
  return 1 unless -f $file;
  return 1 unless open(FILE,"<$file");
  my ($got_prev,$got_next,$got_theme,$got_path);
  while(<FILE>) {
    $got_next = $1 if (/meta\s+NAME='Next_Image'\s+CONTENT='(.+)'/i);
    $got_prev = $1 if (/meta\s+NAME='Prev_Image'\s+CONTENT='(.+)'/i);
    $got_theme = $1 if (/meta\s+NAME='Album_Theme'\s+CONTENT='(.+)'/i);
    $got_path = $1 if (/meta\s+NAME='Album_Path'\s+CONTENT='(.+)'/i);
    if ($got_next && $got_prev && $got_theme && $got_path) {
      close(FILE);
      return 1 unless $next eq $got_next;
      return 1 unless $prev eq $got_prev;
      return 1 unless $theme eq $got_theme;
      return 1 unless $path eq $got_path;
      return 0;
    }
  }
  close(FILE);
  return 1;
}

sub write_img_themes {
  my ($opt_H,$data_H,$dir,$post_url) = @_;

  convert_data_to_eperl($opt_H,$data_H);

  my @changed;
  # Which image pages have had source changes?
  for(my $i=0; $i<=$#{$data_H->{'pics'}}; $i++) {
    next unless $data_H->{'image_is_pic'}[$i];

    my $pic = $data_H->{'pics'}[$i];
    my $file = "$opt_H->{'dir'}/$pic$post_url";
    $changed[$i] = dependency_changed("$dir/$file",
      "$dir/$pic",				# The image itself
      $data_H->{'image_caption_files'}[$i],	# The image.txt file
      "$dir/$opt_H->{'captions'}",		# The captions file
      $0,					# Heck, even this program
      "$opt_H->{'theme'}/image.th",		#   or the theme itself
    );
  }

  for(my $i=0; $i<=$#{$data_H->{'pics'}}; $i++) {
    next unless $data_H->{'image_is_pic'}[$i];

    my $pic = $data_H->{'pics'}[$i];
    my $file = "$opt_H->{'dir'}/$pic$post_url";

    # Okay - if the source for this image didn't change, and
    # the prev/next images and theme are the same, *and* the
    # the prev/next images didn't have source changes (because
    # they might have a name change or some such..), *THEN* we
    # can skip generating this file, and save some time.
    my $prev = $i ? $i-1 : $#{$data_H->{'pics'}};
    my $next = $i==$#{$data_H->{'pics'}} ? 0 : $i+1;
    my $pntp_changed = prev_next_theme_path_changed("$dir/$file",
      $data_H->{'pics'}[$prev],$data_H->{'pics'}[$next],$opt_H->{'theme'},$data_H->{'album_path'});

    next unless ($changed[$i] || $pntp_changed || $changed[$prev] || $changed[$next]);

    setup_output($opt_H,"$dir/$file",1);

    # Write the support data/functions
    print ALBUM @{$data_H->{'eperl'}};

    # Set IMAGE_NUM/THIS_IMAGE
    print ALBUM "<: \$IMAGE_PAGE = 1; \$IMAGE_CNT = $i; \$THIS_IMAGE = $i; :>//\n";

    # Then write the theme
    print ALBUM "#change file: $opt_H->{'image.th.line'} \"$opt_H->{'image.th'}\"\n";
    print ALBUM @{$opt_H->{"image.th.data"}};

    # End support
    print ALBUM @{$data_H->{'end_eperl'}};

    close_output($opt_H,1);
  }
}

#########################
# Table stuff
#########################
my $TABLE_COUNT;
sub start_table {
  $TABLE_COUNT = 0;
  print ALBUM "  <table cellspacing='10' width='95%'>\n";
  print ALBUM "    <tr>\n";
}

sub end_table {
  print ALBUM "       </td>\n";
  print ALBUM "    </tr>\n";
  print ALBUM "  </table>\n";
}

# Return true if we started a new row
sub new_element {
  my ($opt_H) = @_;
  my $new_row = 0;
  if ($TABLE_COUNT) {
    print ALBUM "      </td>\n";
    unless ($TABLE_COUNT % $opt_H->{'columns'}) {
      print ALBUM "    </tr><tr>\n";
      $new_row=1;
    }
  }
  print ALBUM "      <td align='center' ";
  print ALBUM "width='",(100/$opt_H->{'columns'}),"%' "
    if ($TABLE_COUNT < $opt_H->{'columns'});
  print ALBUM "valign='top'>\n";
  $TABLE_COUNT++;
}

#########################
# Default HTML (no ePerl)
#########################
sub caption {
  my ($cap,$capfile) = @_;
  if (-f $capfile && open(CAP,"<$capfile")) {
    while(<CAP>) { print ALBUM; }
    close CAP;
    return;	# Don't use both captions?
  }
  print ALBUM $cap if $cap;
}

sub write_index {
  my ($opt_H,$d_H,$dir) = @_;

  # TOP
  setup_output($opt_H,$d_H->{'album_filename'});
  header($opt_H,0,$dir,@{$d_H->{'parent_albums'}});

  # DIRECTORIES
  if ($d_H->{'child_album_urls'} && @{$d_H->{'child_album_urls'}}) {
    start_table();
    new_element($opt_H);
    print ALBUM "<font size='+2'><i>More albums:</i></font>\n";

    for(my $i=0; $i<=$#{$d_H->{'child_album_urls'}}; $i++) {
      new_element($opt_H);
      print ALBUM "<font size='+1'><a href=$d_H->{'child_album_urls'}[$i]>$d_H->{'child_album_names'}[$i]</a></font>\n";
    }
    end_table();
    print ALBUM "<hr />\n";
  }

  # IMAGES
  start_table();
  for(my $i=0; $i<=$#{$d_H->{'pics'}}; $i++) {
    new_element($opt_H);

    # Picture - thumbnail and all..
    if ($d_H->{'image_is_pic'}[$i]) {
      print ALBUM "        <a href=$d_H->{'image_urls'}[$i]>\n";
      print ALBUM "          <img ";
      print ALBUM "width='$opt_H->{'x'}' height='$opt_H->{'y'}' " if $opt_H->{crop};
      print ALBUM "border='0' src=$d_H->{'image_thumbs'}[$i] alt=$d_H->{'image_alts'}[$i]><br />\n";
      print ALBUM "          $d_H->{'image_names'}[$i]\n";
      print ALBUM "          <font size='-1'><i>[$d_H->{'image_filesizes'}[$i]]</i></font>\n"
        if ($opt_H->{'file_sizes'});
      print ALBUM "        </a><br />\n";

    # Not a picture?
    } else {
      my $type = ($d_H->{'image_names'}[$i] =~ /\.([^\.]+)$/) ? $1 : "??";
      print ALBUM "        <font size='+1'><b>$type file:</b></font>\n";
      print ALBUM "        <p>\n";
      print ALBUM "        <a href=$d_H->{'image_urls'}[$i]>\n";
      print ALBUM "          $d_H->{'image_names'}[$i]\n";
      print ALBUM "          <font size='-1'><i>[$d_H->{'image_filesizes'}[$i]]</i></font>\n"
        if ($opt_H->{'file_sizes'});
      print ALBUM "        </a><br />\n";
    }

    # Caption?
    print ALBUM "          <font size='-2'>\n";
    caption($d_H->{'image_captions'}[$i],$d_H->{'image_caption_files'}[$i]);
    print ALBUM "          </font>\n";
  }

  end_table();
  print ALBUM "<hr />\n" if (@{$d_H->{'pics'}});
  footer($dir);

  close_output($opt_H,0);
}

# Image pages
sub write_img_indexes {
  my ($opt_H,$d_H,$dir,$post_url) = @_;

  my $prev_url = $d_H->{'image_page_urls'}[-1];
  my $prev_name = $d_H->{'image_names'}[-1];

  for(my $i=0; $i<=$#{$d_H->{'pics'}}; $i++) {
    next unless $d_H->{'image_is_pic'}[$i];
    my $img = $d_H->{'image_image_urls'}[$i];
    my $medium = $d_H->{'image_mediums'}[$i] || $img;
    my $pic = $d_H->{'pics'}[$i];
    my $url = $d_H->{'image_page_urls'}[$i];
    my $name = $d_H->{'image_names'}[$i];
    my $next_url = $i+1 > $#{$d_H->{'image_page_urls'}} ? $d_H->{'image_page_urls'}[0] : $d_H->{'image_page_urls'}[$i+1];
    my $next_name = $i+1 > $#{$d_H->{'image_names'}} ? $d_H->{'image_names'}[0] : $d_H->{'image_names'}[$i+1];

    my $file = "$opt_H->{'dir'}/$pic$post_url";
    setup_output($opt_H,"$dir/$file",0);
    header($opt_H,1,$dir,@{$d_H->{'parent_albums'}},$pic);

    # Image and Previous/next
    my $prev_next = <<PREV_NEXT;
<table cellspacing='10' width='100%'>
  <tr>
    <td align='left'>
      <h3><a href=$prev_url>$prev_name</a></h3>
    </td>
    <td align='right'>
      <h3><a href=$next_url>$next_name</a></h3>
    </td>
  </tr>
</table>
PREV_NEXT

    print ALBUM $prev_next;

    print ALBUM "<center><i><font size='+1'>\n";
    print ALBUM "<a href=$img>\n";
    print ALBUM "<img border='0' src=$medium alt=$d_H->{'image_alts'}[$i]></a><br />\n";
    caption($d_H->{'image_captions'}[$i],$d_H->{'image_caption_files'}[$i]);
    print ALBUM "</font></i></center>\n";

    print ALBUM $prev_next;

    print ALBUM "<hr />\n";

    footer($dir);

    close_output($opt_H,0);

    $prev_url = $url;
    $prev_name = $name;
  }
}

#########################
# Make an album
#########################
sub do_album {
  my ($opt_H,$dir,@dir_names) = @_;

  print STDERR "Album: $dir\n";

  #########################
  # Get images and subdirectories
  #########################
  opendir(DIR,$dir);
  my (@dir) = grep(!/^\.{1,2}$/, readdir(DIR));
  closedir(DIR);

  my @new_dirs = grep(-d "$dir/$_" &&
                      !-f "$dir/$_/$HIDE_ALBUM" &&
                      $_ ne $opt_H->{'dir'} &&
                      ($opt_H->{'all'} || !/^\./),
                      @dir);

  # Ignore:
  my @pics = grep(-f "$dir/$_" && 
                  -s "$dir/$_" &&	# Not zero byte file
                  !/\Q$NOT_IMG\E$/ &&	# The "file.$NOT_IMG" files
                  !/\.txt$/ &&		# Per image captions
                  !/\.htaccess$/ &&	# httpd security files
                  !/~$/ &&		# Emacs backup files
                  $_ ne "$opt_H->{'index'}$HTML" &&	# Index html
                  $_ ne $HEADER &&	# Header/footer
                  $_ ne $FOOTER &&      
                  #!(/\Q$HTML\E$/ && -f "$dir/$`") &&	# Image page
                  $_ ne $opt_H->{'captions'},	# Captions file
                  @dir);

  # Clean out thumbnail directory of images we don't have anymore
  clean_thumb_dir($opt_H,"$dir/$opt_H->{'dir'}",@pics)
    if ($opt_H->{'clean'} && -d "$dir/$opt_H->{'dir'}");

  #########################
  # Did we create the index file here?
  #########################
  return if (unknown_html($opt_H,$dir));
  # We may be using album to regenerate just a section of an album,
  # in this case, start with the PATH found in unknown_html()
  @dir_names = split(/\//,$PATH) if (!$#dir_names && $PATH);

  #########################
  # Read captions file
  #########################
  my $caps_H = read_captions($opt_H,$dir);
  # The captions file can rename this directory too, actually
  $dir_names[-1] = $caps_H->{$dir_names[-1]}{name} if ($caps_H->{$dir_names[-1]});

  #########################
  # Sort the pictures, possibly by caption order
  #########################
  @pics = sort { caption_order($caps_H,$a,$b); } @pics;

  #########################
  # Write the html
  #########################
  my %d;	# Hold the theme data

  $d{'album_filename'} = "$dir/$opt_H->{'index'}$HTML";

  @{$d{'parent_albums'}} = map(clean_name($_,undef), @dir_names);
  $d{'album_path'} = join("/",@dir_names);
  $d{'dir'} = $dir;

  #########################
  # Links to sub-albums
  #########################
  if (@new_dirs) {
    foreach my $new ( sort { caption_order($caps_H,$a,$b); } @new_dirs ) {
      push(@{$d{'child_album_names'}},clean_name($new,$caps_H));
      my $url = ($opt_H->{'index'} eq $DEFAULT_INDEX) ?
                "$new/" : "$new/$opt_H->{'index'}$HTML";
      push(@{$d{'child_album_urls'}},quote($url,$opt_H));
    }
  }

  # Image page URLs are <img.html> or <img.indexname.html>
  my $page_post_url = ($opt_H->{'index'} eq $DEFAULT_INDEX) ?
                       $HTML : ".$opt_H->{'index'}$HTML";

  #########################
  # Table of thumbnails
  #########################
  if (@pics) {

    for (my $i=0; $i<=$#pics; $i++) {
      my $pic = $pics[$i];
      my $name = clean_name($pic,$caps_H);
      # Image caption file (image_name.txt)
      my $img_cap = "$dir/$pic";  $img_cap =~ s/\.[^\.]+$//;  $img_cap.=".txt";
      my $size; $size = filesize "$dir/$pic" if ($opt_H->{'file_sizes'});

      # Figure out type
      my $is_a_pic = 1;
      $is_a_pic = 0
        if (-f "${pic}$NOT_IMG" || $pic =~ /\.html?$/i ||
                  $pic =~ /\.(mov|mpg|mpeg)$/ ||
                 ($opt_H->{'known_images'} && $pic !~ /\.($IMAGE_TYPES)$/i));

      my ($width,$height);
      my ($thumb,$page_thumb,$medium);
      if ($is_a_pic) {
        # Generate -medium if necessary
        $medium = medium($opt_H,"$dir/$pic");

        ($width,$height) = get_size($opt_H,
          $medium ? "$dir/$opt_H->{'dir'}/$medium" : "$dir/$pic")
          if ($opt_H->{'image_sizes'});

        # Generate thumbnail
        $thumb = thumbnail($opt_H,"$dir/$pic",$width,$height);

        next unless defined $thumb;
        $thumb =~ s/^\Q$dir\E\/?//; # Ugly - remove path component from $thumb
        $is_a_pic = 0 unless ($thumb);
        $page_thumb = $thumb;
        $page_thumb =~ s/^\Q$opt_H->{'dir'}\E\/?//; # Ugly again
        $thumb = quote($thumb,$opt_H);
        $page_thumb = quote($page_thumb,$opt_H);
      }

      next if ($opt_H->{'known_images'} && !$is_a_pic);

      # URLs (page for each image)?
      # Okay - this gets confusing.  We have three URLs
      # 1) Image_URL from Album
      #    "image_urls"
      #    $pic -or- tn/$pic.html
      # 2) Image_URL from Image page
      #    "image_image_urls"
      #    ../$pic
      # 3) Another Image_Page_URL from Image page
      #    "image_page_urls"
      #    $pic.html
      #
      # If we don't have image pages, we'll only use Image_URL
      #
      my $url;
      if ($is_a_pic && $opt_H->{'image_pages'}) {
        $url = quote("$opt_H->{'dir'}/$pic$page_post_url",$opt_H);
      } else {
        $url = quote($pic,$opt_H);
      }
      my $image_image_url = quote("../$pic",$opt_H);
      my $image_page_url = quote("$pic$page_post_url",$opt_H);
      $medium = quote($medium,$opt_H) if $medium;

      # Add it to our data list
      push(@{$d{'pics'}}, $pic);
      push(@{$d{'image_urls'}}, $url);
      push(@{$d{'image_image_urls'}}, $image_image_url);
      push(@{$d{'image_page_urls'}}, $image_page_url);
      push(@{$d{'image_names'}}, $name);
      push(@{$d{'image_mediums'}}, $medium);
      push(@{$d{'image_page_thumbs'}}, $page_thumb);
      push(@{$d{'image_thumbs'}}, $thumb);
      push(@{$d{'image_widths'}}, $width);
      push(@{$d{'image_heights'}}, $height);
      push(@{$d{'image_filesizes'}}, $size);
      push(@{$d{'image_caption_files'}}, $img_cap);
      push(@{$d{'image_captions'}}, $caps_H->{$pic}{cap});
      # Don't do -fix_urls on alt
      push(@{$d{'image_alts'}}, quote($caps_H->{$pic}{alt}));
      push(@{$d{'image_is_pic'}}, $is_a_pic);
    }
  }

  # Write the HTML
  ($opt_H->{'album.th'}) ?
    write_theme($opt_H,\%d) :
    write_index($opt_H,\%d,$dir);

  #########################
  # Write the image pages?
  #########################
  ($opt_H->{'image.th'} ?
      write_img_themes($opt_H,\%d,$dir,$page_post_url) :
      write_img_indexes($opt_H,\%d,$dir,$page_post_url) )
    if ($opt_H->{'image_pages'});

  #########################
  # Do all the subdirectories
  #########################
  foreach ( @new_dirs ) { do_album($opt_H,"$dir/$_",@dir_names,$_); }
}

##################################################
# Thumbnail code
##################################################
sub medium_name {
  my ($opt_H,$img) = @_;

  my $post="";
  ($img,$post)=($`,$&) if ($img =~ /\.[^\.\/]+$/);

  return "${img}.med$post" unless ($opt_H->{'dir'});

  my $dir = $opt_H->{'dir'};
  ($dir,$img) = ("$`/$opt_H->{'dir'}",$1) if ($img =~ m|/([^/]*)$|);

  (-d $dir) || mkdir($dir,0755) || die("[$PROGNAME] Couldn't make directory [$dir]\n");

  return "$dir/${img}.med$post"
}

sub thumb_name {
  my ($opt_H,$img) = @_;

  # Remove postfix
  $img =~ s/\.[^\.\/]+$//;

  return "${img}.tn.$opt_H->{'type'}" unless ($opt_H->{'dir'});

  my $dir = $opt_H->{'dir'};
  ($dir,$img) = ("$`/$opt_H->{'dir'}",$1) if ($img =~ m|/([^/]*)$|);

  (-d $dir) || mkdir($dir,0755) || die("[$PROGNAME] Couldn't make directory [$dir]\n");

  return "$dir/${img}.$opt_H->{'type'}"
}

sub get_size {
  my ($opt_H,$img) = @_;

  return (0,0) unless (-f $img);

  my $try_noidentify = 0;	# Did identify fail?

  # Try to use identify if we have it
  if ($IDENTIFY && $opt_H->{'identify'}) {
    print STDERR "get_size() run: $IDENTIFY -ping $img\n" if ($MAIN::DEBUG);
    open(SIZE,"$IDENTIFY -ping \Q$img\E 2>&1 |") ||
      die("[$PROGNAME] Couldn't run identify!  [$IDENTIFY]\n");
    while(<SIZE>) {
      print STDERR "get_size(): $_" if ($MAIN::DEBUG);
      if (/command not found/) {	# Kind of kludgy
        $opt_H->{'identify'} = 0;
        last;
      }
      if (/\s(\d+)x(\d+)(\s|\+)/) {
        close(SIZE);
        return ($1,$2);
      }
    }
    # I wish there was an easy way to tell if they had identify!
    $try_noidentify = 1;
#    die("[$PROGNAME] Can't get [$img] size from '$IDENTIFY -ping' output\n".
#        "\tIf you don't have the $IDENTIFY tool, try the '-noidentify' option\n");
  }

  # Kludgy way to get size, but works with all images that convert reads
  print STDERR "get_size() run: $CONVERT -verbose $img /dev/null\n" if ($MAIN::DEBUG);
  open(SIZE,"$CONVERT -verbose \Q$img\E /dev/null 2>&1 |") ||
    die("[$PROGNAME] Couldn't run convert!  [$CONVERT]\n");
  while(<SIZE>) {
    print STDERR "get_size(): $_" if ($MAIN::DEBUG);
    if(/\s(\d+)x(\d+)(\s|\+)/) {
      close(SIZE);
      $opt_H->{'identify'} = 0 if ($try_noidentify);	# identify didn't work, convert did
      return ($1,$2);
    }
  }
  print STDERR "[$PROGNAME] Can't get [$img] size from 'convert -verbose' output\n";
  print STDERR "\tTry option:  -known_images to ignore garbage files\n"
    unless ($img =~ /\.$IMAGE_TYPES$/i);
  die("\n");
}

sub scale {
  my ($opt_H,$img,$scale,$new,$medium) = @_;

  my $scale = $opt_H->{'sample'} ? "-sample $scale" : "-geometry $scale";

  my $cmd = "$CONVERT $opt_H->{'scale_opts'} ";
  $cmd .= ($medium ? $opt_H->{'med_scale_opts'} : $opt_H->{'full_scale_opts'});
  $cmd .= " -verbose \Q$img\E $scale \Q$new\E";
  print STDERR "scale() run: $cmd\n" if ($MAIN::DEBUG);
  open(SIZE,"$cmd 2>&1 |") || die("[$PROGNAME] Couldn't run convert!  [$CONVERT]\n");
  while(<SIZE>) {
    print STDERR "scale(): $_" if ($MAIN::DEBUG);
    if(/=>(\d+)x(\d+)\s/) {
      close(SIZE);
      return ($1,$2);
    }
  }
  close(SIZE);

  # Sometimes convert doesn't give us the new size information
  #print STDERR "[$PROGNAME] Error scaling $img\n";
  get_size($opt_H,$new);
}

sub crop {
  my ($img,$x,$y,$off_x,$off_y,$new) = @_;

  my $cmd = "$CONVERT \Q$img\E -crop ${x}x${y}+${off_x}+${off_y} \Q$new\E";
  print STDERR "crop() run: $cmd\n" if ($MAIN::DEBUG);
  system($cmd);
  return unless ($?);
  print STDERR "[$PROGNAME] Error cropping $img\n";
}

#########################
# Generate the thumbnail
#########################
sub medium {
  my ($opt_H,$img) = @_;

  return unless $opt_H->{'medium'};

  my $med_path = medium_name($opt_H,$img);
  my $medium = $med_path;  $medium =~ s|.*/||g;

  # Don't regenerate mediums if we don't need to.
  return $medium if (-f $med_path && !$opt_H->{'force'} && -M $med_path < -M $img);

  # If the scaling is <width>x<height>, add ">" on the end so that
  # convert will only shrink the images, never grow them
  $opt_H->{'medium'}.='\>' if ($opt_H->{'medium'} =~ /^\d+x\d+$/);

  my ($tx,$ty) = scale($opt_H,$img,$opt_H->{'medium'},$med_path,1);
  return undef unless $tx;
  return $medium;
}

sub thumbnail {
  my ($opt_H,$img,$x,$y) = @_;

  print STDERR "\nIMAGE: $img\n" if ($MAIN::DEBUG);

  my ($thumb) = thumb_name($opt_H,$img);

  # Don't regenerate thumbs if we don't need to.
  return $thumb if (-f $thumb && !$opt_H->{'force'} && -M $thumb < -M $img);

  # In case we didn't get the size yet
  ($x,$y) = get_size($opt_H,$img) unless ($opt_H->{'image_sizes'});

  # Which way do we need to shrink?  convert will scale down w/ aspect
  # as much as is needed to *fit* inside the geometry we give it
  # Hack:  Assume the image is larger than a thumbnail
  my ($scale_x,$scale_y) = ($opt_H->{'x'},$opt_H->{'y'});
  if ($opt_H->{'crop'}) {
    if ( $x/$opt_H->{'x'} < $y/$opt_H->{'y'} ) {
      # Make vertical bigger so that we don't scale horizontal past $opt_H->{'x'}
      $scale_y = $y;
    } else {
      $scale_x = $x;
    }
  }
  my ($tx,$ty) = scale($opt_H,$img,$scale_x."x".$scale_y,$thumb,0);
  return undef unless $tx;

  if ($opt_H->{'crop'}) {
    # Now crop the other dimension
    my ($off_x,$off_y) = (0,0);

    $off_x = int(($tx-$opt_H->{'x'})/2) if ( $tx > $opt_H->{'x'} );
    $off_y = int(($ty-$opt_H->{'y'})/2) if ($ty > $opt_H->{'y'} );

    # Do they have any cropping directives in the image name?
    if ($img =~ /CROP(top|bottom|left|right)\.[^\.]+$/) {
      $off_y = 0 if ($1 eq "top");
      $off_y = $ty-$opt_H->{'y'} if ($1 eq "bottom");
      $off_x = 0 if ($1 eq "left");
      $off_x = $tx-$opt_H->{'x'} if ($1 eq "right");
    }

    crop($thumb,$opt_H->{'x'},$opt_H->{'y'},$off_x,$off_y,$thumb)
      unless ($tx==$opt_H->{'x'} && $ty==$opt_H->{'y'});
  }

  $thumb;
}

##################################################
# Main code
##################################################
sub main {
  my ($opt_H,$dir) = parse_args();

  my $name = abs_path($dir);
  $name =~ s|.*/||;

  do_album($opt_H,$dir,$name);
}
main();
